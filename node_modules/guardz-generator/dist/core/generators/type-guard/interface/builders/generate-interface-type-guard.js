"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInterfaceTypeGuard = void 0;
const ast_1 = require("../../../../../shared/utils/ast");
const convert_type_to_guard_1 = require("../../handlers/convert-type-to-guard");
const generate_property_guard_1 = require("./generate-property-guard");
const generateInterfaceTypeGuard = (interfaceDecl, guardName, allInterfaces, sourceFiles, importMap, currentSourceFile) => {
    // Check if this interface has only index signatures
    if ((0, ast_1.hasOnlyIndexSignatures)(interfaceDecl)) {
        const { keyType, valueType } = (0, ast_1.extractIndexSignatureTypes)(interfaceDecl);
        if (valueType) {
            const context = { sourceFiles, importMap, currentSourceFile };
            const valueTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(valueType, context);
            const keyTypeGuard = keyType
                ? (0, convert_type_to_guard_1.convertTypeToGuard)(keyType, context)
                : 'isString';
            return `export const ${guardName} = isIndexSignature(${keyTypeGuard}, ${valueTypeGuard});`;
        }
    }
    const heritageTypes = (0, ast_1.extractHeritageClauses)(interfaceDecl);
    const hasInheritance = heritageTypes.length > 0;
    // Use the new recursion detection if we have all interfaces, otherwise fall back to the old method
    const isRecursive = allInterfaces
        ? (0, ast_1.isRecursiveOrCyclic)(interfaceDecl)
        : (0, ast_1.isRecursiveType)(interfaceDecl);
    const context = { sourceFiles, importMap, currentSourceFile };
    if (hasInheritance && allInterfaces) {
        // Handle inheritance using isExtensionOf
        const baseInterface = allInterfaces.find(int => int.name.text === heritageTypes[0]);
        if (baseInterface) {
            // Get all inherited property names
            const inheritedProps = (0, ast_1.extractPropertiesWithInheritance)(baseInterface, allInterfaces).map(p => p.name);
            // Get only the properties that are not inherited (current interface properties)
            const currentProperties = (0, ast_1.extractProperties)(interfaceDecl).filter(prop => !inheritedProps.includes(prop.name));
            const currentPropertyGuards = currentProperties
                .map(prop => (0, generate_property_guard_1.generatePropertyGuard)(prop, context))
                .join(', ');
            if (currentPropertyGuards) {
                return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isExtensionOf(is${heritageTypes[0]}, isType<${interfaceDecl.name.text}>({ ${currentPropertyGuards} }));`;
            }
            else {
                // If no new properties, just extend the base
                return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = is${heritageTypes[0]};`;
            }
        }
    }
    // Fall back to regular property extraction (includes inherited properties)
    const properties = allInterfaces
        ? (0, ast_1.extractPropertiesWithInheritance)(interfaceDecl, allInterfaces)
        : (0, ast_1.extractProperties)(interfaceDecl);
    const propertyGuards = properties
        .map(prop => (0, generate_property_guard_1.generatePropertyGuard)(prop, context))
        .join(', ');
    if (isRecursive) {
        return `export function ${guardName}(value: unknown, config?: TypeGuardFnConfig | null): value is ${interfaceDecl.name.text} {\n  return isType<${interfaceDecl.name.text}>({ ${propertyGuards} })(value, config);\n}`;
    }
    else {
        return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isType<${interfaceDecl.name.text}>({ ${propertyGuards} });`;
    }
};
exports.generateInterfaceTypeGuard = generateInterfaceTypeGuard;
//# sourceMappingURL=generate-interface-type-guard.js.map